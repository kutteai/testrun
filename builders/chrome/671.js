(self.webpackChunkpaycio_wallet=self.webpackChunkpaycio_wallet||[]).push([[671],{15340:function(){},17952:function(t,e,a){"use strict";a.d(e,{T:function(){return d}});var r=a(90749),s=a(37761),n=a(36212),c=a(48302);a(81587);async function o(t,e="ethereum",r="m/44'/60'/0'/0/0"){try{const{ethers:s}=await a.e(96).then(a.bind(a,57908)),n=await Promise.resolve().then(a.bind(a,90749));if(!n.validateMnemonic(t))throw new Error("Invalid seed phrase");const c=await n.mnemonicToSeed(t),o=s.HDNodeWallet.fromSeed(c).derivePath(r);return{address:o.address,privateKey:o.privateKey,publicKey:o.publicKey,mnemonic:t,derivationPath:r,seedPhrase:t,network:e}}catch(t){throw t}}async function l(t,e="ethereum"){if(!(0,c.ko)(t))throw new Error("Invalid seed phrase");const a=i(e),r=await o(t,e,a);return{privateKey:r.privateKey,publicKey:r.publicKey,address:r.address,seedPhrase:r.mnemonic,derivationPath:r.derivationPath}}function i(t,e=0){const a={ethereum:`m/44'/60'/0'/0/${e}`,bsc:`m/44'/60'/0'/0/${e}`,polygon:`m/44'/60'/0'/0/${e}`,avalanche:`m/44'/60'/0'/0/${e}`,arbitrum:`m/44'/60'/0'/0/${e}`,optimism:`m/44'/60'/0'/0/${e}`,bitcoin:`m/44'/0'/0'/0/${e}`,litecoin:`m/44'/2'/0'/0/${e}`,solana:`m/44'/501'/0'/0'/${e}'`,tron:`m/44'/195'/0'/0/${e}`,xrp:`m/44'/144'/0'/0/${e}`,ton:`m/44'/396'/0'/0/${e}`};return a[t]||a.ethereum}class d{constructor(){this.wallets=[],this.loadWallets()}async loadWallets(){try{chrome.storage.local.get(["wallets"],t=>{t.wallets&&(this.wallets=t.wallets)})}catch(t){}}async saveWallets(){try{chrome.storage.local.set({wallets:this.wallets})}catch(t){}}generateSeedPhrase(){const t=s.p(16);return r.entropyToMnemonic(n.c$(t))}validateSeedPhrase(t){return r.validateMnemonic(t)}async createWallet(t){try{const e=this.generateSeedPhrase(),a=await(0,c.encryptData)(e,t.password),r=await this.deriveAccounts(e,t.network,t.accountCount||1),s=r[0],n={id:Date.now().toString(),name:t.name,address:s.address,seedPhrase:e,privateKey:s.privateKey,publicKey:s.publicKey,network:t.network,currentNetwork:t.network,derivationPath:s.derivationPath,createdAt:Date.now(),encryptedSeedPhrase:a,accounts:r,lastAccessed:Date.now()};return this.wallets.push(n),await this.saveWallets(),n}catch(t){throw t}}async importWallet(t){try{if(!this.validateSeedPhrase(t.seedPhrase))throw new Error("Invalid seed phrase");const e=await(0,c.encryptData)(t.seedPhrase,t.password),a=await this.deriveAccounts(t.seedPhrase,t.network,t.accountCount||1),r=a[0],s={id:Date.now().toString(),name:t.name,address:r.address,seedPhrase:t.seedPhrase,privateKey:r.privateKey,publicKey:r.publicKey,network:t.network,currentNetwork:t.network,derivationPath:r.derivationPath,createdAt:Date.now(),encryptedSeedPhrase:e,accounts:a,lastAccessed:Date.now()};return this.wallets.push(s),await this.saveWallets(),s}catch(t){throw t}}async deriveAccounts(t,e,a){const r=[];for(let s=0;s<a;s++)try{const a=`m/44'/60'/0'/0/${s}`,n=await l(t,a),c={id:`${Date.now()}-${s}`,address:n.address,privateKey:n.privateKey,publicKey:n.publicKey,derivationPath:a,network:e,balance:"0",nonce:0,createdAt:Date.now()};r.push(c)}catch(t){}return r}getWallet(t){return this.wallets.find(e=>e.id===t)}getAllWallets(){return this.wallets}getWalletByName(t){return this.wallets.find(e=>e.name===t)}getWalletAccounts(t){const e=this.getWallet(t);return e?e.accounts:[]}getAccountByAddress(t){for(const e of this.wallets){const a=e.accounts.find(e=>e.address.toLowerCase()===t.toLowerCase());if(a)return a}}async addAccount(t,e){const a=this.getWallet(t);if(!a)throw new Error("Wallet not found");const r=await(0,c.decryptData)(a.encryptedSeedPhrase,e);if(!r)throw new Error("Invalid password");const s=a.accounts.length,n=`m/44'/60'/0'/0/${s}`,o=await l(r,n),i={id:`${Date.now()}-${s}`,address:o.address,privateKey:o.privateKey,publicKey:o.publicKey,derivationPath:n,network:a.network,balance:"0",nonce:0,createdAt:Date.now()};return a.accounts.push(i),a.lastAccessed=Date.now(),await this.saveWallets(),i}async updateAccountBalance(t,e){const a=this.getAccountByAddress(t);a&&(a.balance=e,await this.saveWallets())}async updateAccountNonce(t,e){const a=this.getAccountByAddress(t);a&&(a.nonce=e,await this.saveWallets())}async exportWallet(t,e){const a=this.getWallet(t);if(!a)throw new Error("Wallet not found");const r=await(0,c.decryptData)(a.encryptedSeedPhrase,e);if(!r)throw new Error("Invalid password");return r}async changePassword(t,e,a){const r=this.getWallet(t);if(!r)throw new Error("Wallet not found");const s=await(0,c.decryptData)(r.encryptedSeedPhrase,e);if(!s)throw new Error("Invalid old password");const n=await(0,c.encryptData)(s,a);r.encryptedSeedPhrase=n,r.lastAccessed=Date.now(),await this.saveWallets()}async deleteWallet(t){const e=this.wallets.findIndex(e=>e.id===t);-1!==e&&(this.wallets.splice(e,1),await this.saveWallets())}getWalletStats(){return{totalWallets:this.wallets.length,totalAccounts:this.wallets.reduce((t,e)=>t+e.accounts.length,0),totalBalance:this.wallets.reduce((t,e)=>t+e.accounts.reduce((t,e)=>t+parseFloat(e.balance),0),0).toString(),networks:Array.from(new Set(this.wallets.map(t=>t.network)))}}async validatePassword(t,e){const a=this.getWallet(t);if(!a)return!1;try{return!!await(0,c.decryptData)(a.encryptedSeedPhrase,e)}catch(t){return!1}}getWalletByAddress(t){return this.wallets.find(e=>e.accounts.some(e=>e.address.toLowerCase()===t.toLowerCase()))}async backupWallet(t,e){const a=this.getWallet(t);if(!a)throw new Error("Wallet not found");const r=await(0,c.decryptData)(a.encryptedSeedPhrase,e);if(!r)throw new Error("Invalid password");const s={name:a.name,seedPhrase:r,network:a.network,createdAt:a.createdAt,accounts:a.accounts.map(t=>({address:t.address,derivationPath:t.derivationPath}))};return JSON.stringify(s,null,2)}async restoreWallet(t,e){try{const a=JSON.parse(t),r={name:a.name,seedPhrase:a.seedPhrase,password:e,network:a.network,accountCount:a.accounts?.length||1};return await this.importWallet(r)}catch(t){throw new Error("Invalid backup data")}}getCurrentWallet(){if(0===this.wallets.length)return null;return[...this.wallets].sort((t,e)=>e.lastAccessed-t.lastAccessed)[0]}getCurrentWalletForBackground(){if(0===this.wallets.length)return null;const t=this.wallets[0];return t.accounts&&0!==t.accounts.length?{address:t.accounts[0].address,currentNetwork:t.network}:null}getCurrentAccount(){const t=this.getCurrentWallet();return t&&0!==t.accounts.length?t.accounts[0]:null}async getBalance(t,e){try{if(!this.getAccountByAddress(t))throw new Error("Account not found");const{getRealBalance:r}=await a.e(336).then(a.bind(a,18336)),s=await r(t,e);return await this.updateAccountBalance(t,s),s}catch(t){return"0"}}async switchNetwork(t){const e=this.getCurrentWallet();if(!e)throw new Error("No wallet available");e.network=t,e.lastAccessed=Date.now(),await this.saveWallets()}getAllAccounts(){return this.wallets.flatMap(t=>t.accounts)}getAccountsByNetwork(t){return this.getAllAccounts().filter(e=>e.network===t)}}},21638:function(){},38664:function(){},47790:function(){},50477:function(){},73776:function(){},79838:function(){},92668:function(){},98285:function(){}}]);