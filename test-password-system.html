<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PayCio Wallet Password System Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #180CB2;
            text-align: center;
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .test-section h3 {
            color: #333;
            margin-top: 0;
        }
        button {
            background: #180CB2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #1409a0;
        }
        input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            margin: 5px;
            width: 200px;
        }
        .result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 3px;
        }
        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        pre {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 3px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê PayCio Wallet Password System Test</h1>
        
        <div class="test-section">
            <h3>1. Test Password Hash Generation</h3>
            <input type="password" id="testPassword" placeholder="Enter test password" />
            <button onclick="testPasswordHash()">Test Hash Generation</button>
            <div id="hashResult"></div>
        </div>

        <div class="test-section">
            <h3>2. Test Encryption/Decryption</h3>
            <input type="text" id="testData" placeholder="Enter data to encrypt" value="abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about" />
            <input type="password" id="encryptPassword" placeholder="Enter encryption password" />
            <button onclick="testEncryption()">Test Encryption</button>
            <div id="encryptResult"></div>
        </div>

        <div class="test-section">
            <h3>3. Test Background Script Communication</h3>
            <input type="password" id="unlockPassword" placeholder="Enter unlock password" />
            <button onclick="testUnlock()">Test Wallet Unlock</button>
            <div id="unlockResult"></div>
        </div>

        <div class="test-section">
            <h3>4. Debug Wallet Storage</h3>
            <button onclick="debugStorage()">Analyze Storage</button>
            <div id="storageResult"></div>
        </div>
    </div>

    <script>
        // Unified Crypto Implementation (same as background script)
        class UnifiedCrypto {
            static async deriveKey(password, salt) {
                const encoder = new TextEncoder();
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(password),
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits', 'deriveKey']
                );

                return crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['encrypt', 'decrypt']
                );
            }

            static async encrypt(plaintext, password) {
                const encoder = new TextEncoder();
                const salt = crypto.getRandomValues(new Uint8Array(16));
                const iv = crypto.getRandomValues(new Uint8Array(12));
                
                const key = await this.deriveKey(password, salt);
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encoder.encode(plaintext)
                );

                const result = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
                result.set(salt, 0);
                result.set(iv, salt.length);
                result.set(new Uint8Array(encrypted), salt.length + iv.length);
                
                return btoa(String.fromCharCode(...result));
            }

            static async decrypt(encryptedData, password) {
                try {
                    const data = new Uint8Array(
                        atob(encryptedData).split('').map(c => c.charCodeAt(0))
                    );
                    
                    const salt = data.slice(0, 16);
                    const iv = data.slice(16, 28);
                    const encrypted = data.slice(28);
                    
                    const key = await this.deriveKey(password, salt);
                    const decrypted = await crypto.subtle.decrypt(
                        { name: 'AES-GCM', iv: iv },
                        key,
                        encrypted
                    );
                    
                    return new TextDecoder().decode(decrypted);
                } catch (error) {
                    throw new Error('Decryption failed - invalid password or corrupted data');
                }
            }

            static async hashPassword(password) {
                const encoder = new TextEncoder();
                const data = encoder.encode(password);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }
        }

        async function testPasswordHash() {
            const password = document.getElementById('testPassword').value;
            if (!password) {
                showResult('hashResult', 'Please enter a password', 'error');
                return;
            }

            try {
                const hash = await UnifiedCrypto.hashPassword(password);
                showResult('hashResult', `Password hash: ${hash}`, 'success');
            } catch (error) {
                showResult('hashResult', `Error: ${error.message}`, 'error');
            }
        }

        async function testEncryption() {
            const data = document.getElementById('testData').value;
            const password = document.getElementById('encryptPassword').value;
            
            if (!data || !password) {
                showResult('encryptResult', 'Please enter both data and password', 'error');
                return;
            }

            try {
                // Encrypt
                const encrypted = await UnifiedCrypto.encrypt(data, password);
                showResult('encryptResult', `Encrypted: ${encrypted.substring(0, 50)}...`, 'info');
                
                // Decrypt
                const decrypted = await UnifiedCrypto.decrypt(encrypted, password);
                const isMatch = decrypted === data;
                showResult('encryptResult', 
                    `Decrypted: ${decrypted.substring(0, 50)}...<br>Match: ${isMatch ? '‚úÖ YES' : '‚ùå NO'}`, 
                    isMatch ? 'success' : 'error'
                );
            } catch (error) {
                showResult('encryptResult', `Error: ${error.message}`, 'error');
            }
        }

        async function testUnlock() {
            const password = document.getElementById('unlockPassword').value;
            if (!password) {
                showResult('unlockResult', 'Please enter a password', 'error');
                return;
            }

            try {
                // Check if we're in extension context
                if (typeof chrome === 'undefined' || !chrome.runtime) {
                    showResult('unlockResult', 'This test requires the extension context. Open this page from the extension popup.', 'error');
                    return;
                }

                const response = await new Promise((resolve) => {
                    chrome.runtime.sendMessage({
                        type: 'UNLOCK_WALLET',
                        password: password
                    }, resolve);
                });

                showResult('unlockResult', `Background response: ${JSON.stringify(response)}`, 
                    response.success ? 'success' : 'error');
            } catch (error) {
                showResult('unlockResult', `Error: ${error.message}`, 'error');
            }
        }

        async function debugStorage() {
            try {
                // Check if we're in extension context
                if (typeof chrome === 'undefined' || !chrome.storage) {
                    showResult('storageResult', 'This test requires the extension context. Open this page from the extension popup.', 'error');
                    return;
                }

                const storageData = await new Promise((resolve) => {
                    chrome.storage.local.get(null, resolve);
                });

                const wallet = storageData.wallet;
                const passwordHash = storageData.passwordHash;
                const walletState = storageData.walletState;

                let result = '<h4>Storage Analysis:</h4>';
                result += `<p><strong>Storage keys:</strong> ${Object.keys(storageData).join(', ')}</p>`;
                result += `<p><strong>Has wallet:</strong> ${!!wallet}</p>`;
                result += `<p><strong>Has password hash:</strong> ${!!passwordHash}</p>`;
                result += `<p><strong>Has wallet state:</strong> ${!!walletState}</p>`;

                if (wallet) {
                    result += `<p><strong>Wallet ID:</strong> ${wallet.id}</p>`;
                    result += `<p><strong>Wallet name:</strong> ${wallet.name}</p>`;
                    result += `<p><strong>Has encrypted seed phrase:</strong> ${!!wallet.encryptedSeedPhrase}</p>`;
                    result += `<p><strong>Has legacy password:</strong> ${!!wallet.password}</p>`;
                    result += `<p><strong>Current address:</strong> ${wallet.address}</p>`;
                }

                if (walletState) {
                    result += `<p><strong>Is unlocked:</strong> ${walletState.isWalletUnlocked}</p>`;
                    result += `<p><strong>Last unlock time:</strong> ${walletState.lastUnlockTime ? new Date(walletState.lastUnlockTime).toLocaleString() : 'Never'}</p>`;
                }

                showResult('storageResult', result, 'info');
            } catch (error) {
                showResult('storageResult', `Error: ${error.message}`, 'error');
            }
        }

        function showResult(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="result ${type}">${message}</div>`;
        }

        // Auto-load debug tool if in extension context
        if (typeof chrome !== 'undefined' && chrome.runtime) {
            console.log('üîß PayCio Password Test Tool loaded');
            console.log('üîß Use the buttons above to test different aspects of the password system');
        }
    </script>
</body>
</html>
