<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PayCio Wallet Discovery Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .test-section {
            background: #f5f5f5;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border-left: 4px solid #180CB2;
        }
        .success { border-left-color: #10b981; background: #f0fdf4; }
        .error { border-left-color: #ef4444; background: #fef2f2; }
        .warning { border-left-color: #f59e0b; background: #fffbeb; }
        button {
            background: #180CB2;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        button:hover { background: #1409a0; }
        button:disabled { background: #9ca3af; cursor: not-allowed; }
        .log {
            background: #1f2937;
            color: #f9fafb;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .provider-info {
            background: white;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            border: 1px solid #e5e7eb;
        }
    </style>
</head>
<body>
    <h1>üîç PayCio Wallet Discovery Test</h1>
    <p>This page tests whether your PayCio wallet is properly discoverable by dApp servers.</p>

    <div class="test-section">
        <h3>üì° Provider Detection Tests</h3>
        <button onclick="testWindowEthereum()">Test window.ethereum</button>
        <button onclick="testEIP6963()">Test EIP-6963 Discovery</button>
        <button onclick="testProviderMethods()">Test Provider Methods</button>
        <button onclick="triggerEIP6963Request()">Trigger EIP-6963 Request</button>
        <button onclick="clearLog()">Clear Log</button>
        <div id="provider-results"></div>
    </div>

    <div class="test-section">
        <h3>üîó Connection Tests</h3>
        <button onclick="testConnection()">Test Wallet Connection</button>
        <button onclick="testConnectionWithPayCio()">Test PayCio Connection</button>
        <button onclick="testConnectionWithMetaMask()">Test MetaMask Connection</button>
        <button onclick="testAccounts()">Get Accounts</button>
        <button onclick="testChainId()">Get Chain ID</button>
        <div id="connection-results"></div>
    </div>

    <div class="test-section">
        <h3>üìã Test Log</h3>
        <div id="log" class="log"></div>
    </div>

    <script>
        let logElement = document.getElementById('log');
        let providerResults = document.getElementById('provider-results');
        let connectionResults = document.getElementById('connection-results');
        let eip6963Providers = [];

        // Set up EIP-6963 listener IMMEDIATELY - before any other code
        const seenProviders = new Set();
        window.addEventListener('eip6963:announceProvider', (event) => {
            const { info, provider } = event.detail;
            const key = `${info.name}-${info.uuid}`;
            
            if (!seenProviders.has(key)) {
                seenProviders.add(key);
                eip6963Providers.push({ info, provider });
                console.log('üîî EIP-6963 provider announced:', info.name, info.uuid);
                log(`üîî EIP-6963 provider announced: ${info.name} (${info.uuid})`, 'success');
            }
        });

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            logElement.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        function clearLog() {
            logElement.textContent = '';
            providerResults.innerHTML = '';
            connectionResults.innerHTML = '';
        }

        function triggerEIP6963Request() {
            log('Manually triggering EIP-6963 request...');
            window.dispatchEvent(new CustomEvent('eip6963:requestProvider'));
            log('EIP-6963 request sent. Check console for announcements.', 'info');
        }

        function addResult(container, title, content, type = 'info') {
            const div = document.createElement('div');
            div.className = `provider-info ${type}`;
            div.innerHTML = `<strong>${title}</strong><br>${content}`;
            container.appendChild(div);
        }

        // Test 1: window.ethereum detection
        function testWindowEthereum() {
            log('Testing window.ethereum detection...');
            
            if (typeof window.ethereum !== 'undefined') {
                log('‚úÖ window.ethereum found!', 'success');
                
                const provider = window.ethereum;
                let info = `
                    <strong>Provider Details:</strong><br>
                    ‚Ä¢ isPayCio: ${provider.isPayCio || 'false'}<br>
                    ‚Ä¢ isMetaMask: ${provider.isMetaMask || 'false'}<br>
                    ‚Ä¢ chainId: ${provider.chainId || 'unknown'}<br>
                    ‚Ä¢ networkVersion: ${provider.networkVersion || 'unknown'}<br>
                    ‚Ä¢ selectedAddress: ${provider.selectedAddress || 'none'}<br>
                `;
                
                if (provider.providers && Array.isArray(provider.providers)) {
                    info += `‚Ä¢ Multiple providers detected: ${provider.providers.length}<br>`;
                    provider.providers.forEach((p, i) => {
                        info += `  - Provider ${i + 1}: ${p.isPayCio ? 'PayCio' : 'Other'}<br>`;
                    });
                }
                
                addResult(providerResults, 'window.ethereum Detection', info, 'success');
            } else {
                log('‚ùå window.ethereum not found', 'error');
                addResult(providerResults, 'window.ethereum Detection', 'No ethereum provider found on window object', 'error');
            }
        }

        // Test 2: EIP-6963 Discovery
        function testEIP6963() {
            log('Testing EIP-6963 provider discovery...');
            log(`Current providers detected: ${eip6963Providers.length}`, 'info');
            
            // Request providers multiple times to catch all announcements
            window.dispatchEvent(new CustomEvent('eip6963:requestProvider'));
            
            // Also check for any existing providers that might have been announced
            setTimeout(() => {
                window.dispatchEvent(new CustomEvent('eip6963:requestProvider'));
            }, 100);
            
            setTimeout(() => {
                window.dispatchEvent(new CustomEvent('eip6963:requestProvider'));
            }, 500);
            
            // Check after a longer delay to catch all announcements
            setTimeout(() => {
                if (eip6963Providers.length > 0) {
                    let info = `<strong>Found ${eip6963Providers.length} provider(s):</strong><br>`;
                    eip6963Providers.forEach((p, i) => {
                        info += `
                            <strong>Provider ${i + 1}:</strong><br>
                            ‚Ä¢ Name: ${p.info.name}<br>
                            ‚Ä¢ UUID: ${p.info.uuid}<br>
                            ‚Ä¢ RDNS: ${p.info.rdns}<br>
                            ‚Ä¢ isPayCio: ${p.provider.isPayCio || 'false'}<br>
                        `;
                    });
                    addResult(providerResults, 'EIP-6963 Discovery', info, 'success');
                } else {
                    log('‚ùå No EIP-6963 providers found', 'error');
                    log('üí° This might be because the provider was injected before the listener was set up', 'warning');
                    addResult(providerResults, 'EIP-6963 Discovery', 'No providers announced via EIP-6963. Try refreshing the page and testing again.', 'error');
                }
            }, 2000);
        }

        // Test 3: Provider Methods
        function testProviderMethods() {
            log('Testing provider methods...');
            
            if (!window.ethereum) {
                log('‚ùå No ethereum provider available for method testing', 'error');
                return;
            }
            
            const provider = window.ethereum;
            const methods = ['request', 'on', 'removeListener', 'isConnected'];
            let availableMethods = [];
            let missingMethods = [];
            
            methods.forEach(method => {
                if (typeof provider[method] === 'function') {
                    availableMethods.push(method);
                } else {
                    missingMethods.push(method);
                }
            });
            
            let info = `<strong>Method Availability:</strong><br>`;
            if (availableMethods.length > 0) {
                info += `‚úÖ Available: ${availableMethods.join(', ')}<br>`;
            }
            if (missingMethods.length > 0) {
                info += `‚ùå Missing: ${missingMethods.join(', ')}<br>`;
            }
            
            const type = missingMethods.length === 0 ? 'success' : 'warning';
            addResult(providerResults, 'Provider Methods', info, type);
        }

        // Test 4: Connection
        async function testConnection() {
            log('Testing wallet connection...');
            
            if (!window.ethereum) {
                log('‚ùå No ethereum provider available', 'error');
                addResult(connectionResults, 'Connection Test', 'No ethereum provider available', 'error');
                return;
            }
            
            try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                log(`üîç Raw accounts response:`, 'info');
                log(`Type: ${typeof accounts}, Is Array: ${Array.isArray(accounts)}`, 'info');
                log(`Value: ${JSON.stringify(accounts)}`, 'info');
                
                // Handle different response formats
                let accountList = [];
                if (Array.isArray(accounts)) {
                    accountList = accounts;
                } else if (accounts && typeof accounts === 'object') {
                    // If it's an object, try to extract accounts
                    if (accounts.accounts && Array.isArray(accounts.accounts)) {
                        accountList = accounts.accounts;
                    } else if (accounts.result && Array.isArray(accounts.result)) {
                        accountList = accounts.result;
                    } else {
                        accountList = [accounts];
                    }
                } else if (accounts) {
                    accountList = [accounts];
                }
                
                if (accountList.length > 0) {
                    log(`‚úÖ Connected successfully! Accounts: ${accountList.join(', ')}`, 'success');
                    addResult(connectionResults, 'Connection Test', `Connected with accounts: ${accountList.join(', ')}`, 'success');
                } else {
                    log('‚ö†Ô∏è Connection successful but no accounts returned', 'warning');
                    addResult(connectionResults, 'Connection Test', 'Connected but no accounts available', 'warning');
                }
            } catch (error) {
                log(`‚ùå Connection failed: ${error.message}`, 'error');
                addResult(connectionResults, 'Connection Test', `Connection failed: ${error.message}`, 'error');
            }
        }

        // Test 5: Get Accounts
        async function testAccounts() {
            log('Testing get accounts...');
            
            if (!window.ethereum) {
                log('‚ùå No ethereum provider available', 'error');
                return;
            }
            
            try {
                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                if (accounts && accounts.length > 0) {
                    log(`‚úÖ Accounts found: ${accounts.join(', ')}`, 'success');
                    addResult(connectionResults, 'Get Accounts', `Found accounts: ${accounts.join(', ')}`, 'success');
                } else {
                    log('‚ö†Ô∏è No accounts found (wallet may not be connected)', 'warning');
                    addResult(connectionResults, 'Get Accounts', 'No accounts found - wallet may not be connected', 'warning');
                }
            } catch (error) {
                log(`‚ùå Failed to get accounts: ${error.message}`, 'error');
                addResult(connectionResults, 'Get Accounts', `Failed: ${error.message}`, 'error');
            }
        }

        // Test PayCio Connection
        async function testConnectionWithPayCio() {
            log('Testing PayCio wallet connection...');
            
            // Find PayCio provider from EIP-6963 providers
            const paycioProvider = eip6963Providers.find(p => p.info.name === 'Paycio Wallet');
            
            if (!paycioProvider) {
                log('‚ùå PayCio provider not found', 'error');
                addResult(connectionResults, 'PayCio Connection', 'PayCio provider not found', 'error');
                return;
            }
            
            try {
                const accounts = await paycioProvider.provider.request({ method: 'eth_requestAccounts' });
                log(`üîç PayCio accounts response:`, 'info');
                log(`Type: ${typeof accounts}, Is Array: ${Array.isArray(accounts)}`, 'info');
                log(`Value: ${JSON.stringify(accounts)}`, 'info');
                
                // Handle different response formats
                let accountList = [];
                if (Array.isArray(accounts)) {
                    accountList = accounts;
                } else if (accounts && typeof accounts === 'object') {
                    if (accounts.accounts && Array.isArray(accounts.accounts)) {
                        accountList = accounts.accounts;
                    } else if (accounts.result && Array.isArray(accounts.result)) {
                        accountList = accounts.result;
                    } else {
                        accountList = [accounts];
                    }
                } else if (accounts) {
                    accountList = [accounts];
                }
                
                if (accountList.length > 0) {
                    log(`‚úÖ PayCio connected successfully! Accounts: ${accountList.join(', ')}`, 'success');
                    addResult(connectionResults, 'PayCio Connection', `Connected with accounts: ${accountList.join(', ')}`, 'success');
                } else {
                    log('‚ö†Ô∏è PayCio connection successful but no accounts returned', 'warning');
                    addResult(connectionResults, 'PayCio Connection', 'Connected but no accounts available', 'warning');
                }
            } catch (error) {
                log(`‚ùå PayCio connection failed: ${error.message}`, 'error');
                addResult(connectionResults, 'PayCio Connection', `Connection failed: ${error.message}`, 'error');
            }
        }

        // Test MetaMask Connection
        async function testConnectionWithMetaMask() {
            log('Testing MetaMask wallet connection...');
            
            // Find MetaMask provider from EIP-6963 providers
            const metamaskProvider = eip6963Providers.find(p => p.info.name === 'MetaMask');
            
            if (!metamaskProvider) {
                log('‚ùå MetaMask provider not found', 'error');
                addResult(connectionResults, 'MetaMask Connection', 'MetaMask provider not found', 'error');
                return;
            }
            
            try {
                const accounts = await metamaskProvider.provider.request({ method: 'eth_requestAccounts' });
                log(`üîç MetaMask accounts response:`, 'info');
                log(`Type: ${typeof accounts}, Is Array: ${Array.isArray(accounts)}`, 'info');
                log(`Value: ${JSON.stringify(accounts)}`, 'info');
                
                // Handle different response formats
                let accountList = [];
                if (Array.isArray(accounts)) {
                    accountList = accounts;
                } else if (accounts && typeof accounts === 'object') {
                    if (accounts.accounts && Array.isArray(accounts.accounts)) {
                        accountList = accounts.accounts;
                    } else if (accounts.result && Array.isArray(accounts.result)) {
                        accountList = accounts.result;
                    } else {
                        accountList = [accounts];
                    }
                } else if (accounts) {
                    accountList = [accounts];
                }
                
                if (accountList.length > 0) {
                    log(`‚úÖ MetaMask connected successfully! Accounts: ${accountList.join(', ')}`, 'success');
                    addResult(connectionResults, 'MetaMask Connection', `Connected with accounts: ${accountList.join(', ')}`, 'success');
                } else {
                    log('‚ö†Ô∏è MetaMask connection successful but no accounts returned', 'warning');
                    addResult(connectionResults, 'MetaMask Connection', 'Connected but no accounts available', 'warning');
                }
            } catch (error) {
                log(`‚ùå MetaMask connection failed: ${error.message}`, 'error');
                addResult(connectionResults, 'MetaMask Connection', `Connection failed: ${error.message}`, 'error');
            }
        }

        // Test 6: Get Chain ID
        async function testChainId() {
            log('Testing get chain ID...');
            
            if (!window.ethereum) {
                log('‚ùå No ethereum provider available', 'error');
                return;
            }
            
            try {
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                log(`‚úÖ Chain ID: ${chainId}`, 'success');
                addResult(connectionResults, 'Get Chain ID', `Chain ID: ${chainId}`, 'success');
            } catch (error) {
                log(`‚ùå Failed to get chain ID: ${error.message}`, 'error');
                addResult(connectionResults, 'Get Chain ID', `Failed: ${error.message}`, 'error');
            }
        }

        // EIP-6963 listener is already set up at the top of the script

        // Auto-run basic tests on page load
        window.addEventListener('load', () => {
            log('üöÄ PayCio Wallet Discovery Test Page Loaded');
            log('Running initial tests...');
            
            setTimeout(() => {
                testWindowEthereum();
                testEIP6963();
                testProviderMethods();
            }, 500);
        });

        // Listen for ethereum events
        if (window.ethereum) {
            window.ethereum.on('connect', (connectInfo) => {
                log(`üîó Wallet connected: ${JSON.stringify(connectInfo)}`, 'success');
            });
            
            window.ethereum.on('disconnect', (error) => {
                log(`üîå Wallet disconnected: ${error.message || 'Unknown reason'}`, 'warning');
            });
            
            window.ethereum.on('accountsChanged', (accounts) => {
                log(`üë§ Accounts changed: ${accounts.join(', ')}`, 'info');
            });
            
            window.ethereum.on('chainChanged', (chainId) => {
                log(`‚õìÔ∏è Chain changed: ${chainId}`, 'info');
            });
        }
    </script>
</body>
</html>
