<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PayCio Address Validation Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 2px solid #e9ecef;
            border-radius: 15px;
            background: #f8f9fa;
        }
        .test-section h3 {
            margin-top: 0;
            color: #495057;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin: 5px;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
        }
        .result {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            background: white;
            border-left: 4px solid #007bff;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        .error {
            border-left-color: #dc3545;
            background: #f8d7da;
        }
        .success {
            border-left-color: #28a745;
            background: #d4edda;
        }
        .warning {
            border-left-color: #ffc107;
            background: #fff3cd;
        }
        .address-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
            margin: 10px 0;
        }
        .network-selector {
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            margin: 5px;
            background: white;
        }
        .validation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .validation-card {
            padding: 15px;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            background: white;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-valid { background: #28a745; }
        .status-invalid { background: #dc3545; }
        .status-warning { background: #ffc107; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê PayCio Address Validation Test</h1>
        
        <div class="test-section">
            <h3>1. Test Individual Address</h3>
            <p>Validate a specific cryptocurrency address</p>
            
            <select class="network-selector" id="network-select">
                <option value="bitcoin">Bitcoin (BTC)</option>
                <option value="ethereum">Ethereum (ETH)</option>
                <option value="litecoin">Litecoin (LTC)</option>
                <option value="solana">Solana (SOL)</option>
                <option value="tron">TRON (TRX)</option>
            </select>
            
            <label>
                <input type="checkbox" id="testnet-checkbox"> Use Testnet
            </label>
            
            <input type="text" class="address-input" id="address-input" 
                   placeholder="Enter cryptocurrency address to validate...">
            
            <button onclick="validateSingleAddress()">Validate Address</button>
            <button onclick="testOnBlockchain()">Test on Blockchain</button>
            
            <div id="single-result" class="result" style="display: none;"></div>
        </div>

        <div class="test-section">
            <h3>2. Test PayCio Generated Addresses</h3>
            <p>Generate and validate addresses from your PayCio wallet</p>
            
            <button onclick="generateAndTestAddresses()">Generate & Test All Networks</button>
            <button onclick="testSpecificNetwork('bitcoin')">Test Bitcoin</button>
            <button onclick="testSpecificNetwork('ethereum')">Test Ethereum</button>
            <button onclick="testSpecificNetwork('litecoin')">Test Litecoin</button>
            <button onclick="testSpecificNetwork('solana')">Test Solana</button>
            
            <div id="generation-result" class="result" style="display: none;"></div>
        </div>

        <div class="test-section">
            <h3>3. Real-World Address Examples</h3>
            <p>Test against known valid addresses from each network</p>
            
            <button onclick="testKnownValidAddresses()">Test Known Valid Addresses</button>
            <button onclick="testKnownInvalidAddresses()">Test Known Invalid Addresses</button>
            
            <div id="examples-result" class="result" style="display: none;"></div>
        </div>

        <div class="test-section">
            <h3>4. Blockchain Explorer Links</h3>
            <p>Quick links to verify addresses on real blockchain explorers</p>
            
            <div id="explorer-links" class="validation-grid"></div>
        </div>
    </div>

    <script>
        console.log('üß™ PayCio Address Validation Test Page Loaded');

        // Address validation functions (simplified for browser)
        function validateBitcoinAddress(address, testnet = false) {
            const errors = [];
            let addressType = 'unknown';
            let isValid = false;

            if (!address) {
                errors.push('Address is required');
                return { isValid, addressType, errors };
            }

            if (testnet) {
                // Testnet patterns
                if (address.startsWith('m') || address.startsWith('n')) {
                    addressType = 'Legacy (P2PKH)';
                    isValid = address.length >= 26 && address.length <= 35;
                } else if (address.startsWith('2')) {
                    addressType = 'SegWit (P2SH)';
                    isValid = address.length >= 26 && address.length <= 35;
                } else if (address.startsWith('tb1')) {
                    addressType = 'Native SegWit (Bech32)';
                    isValid = address.length >= 42 && address.length <= 62;
                }
            } else {
                // Mainnet patterns
                if (address.startsWith('1')) {
                    addressType = 'Legacy (P2PKH)';
                    isValid = address.length >= 26 && address.length <= 35;
                } else if (address.startsWith('3')) {
                    addressType = 'SegWit (P2SH)';
                    isValid = address.length >= 26 && address.length <= 35;
                } else if (address.startsWith('bc1')) {
                    addressType = 'Native SegWit (Bech32)';
                    isValid = address.length >= 42 && address.length <= 62;
                }
            }

            if (!isValid && errors.length === 0) {
                errors.push('Invalid Bitcoin address format');
            }

            return { isValid, addressType, errors };
        }

        function validateEthereumAddress(address) {
            const errors = [];
            let isValid = false;

            if (!address) {
                errors.push('Address is required');
                return { isValid, addressType: 'EOA', errors };
            }

            if (!address.startsWith('0x')) {
                errors.push('Ethereum address must start with 0x');
            } else if (address.length !== 42) {
                errors.push('Ethereum address must be 42 characters long');
            } else if (!/^0x[0-9a-fA-F]{40}$/.test(address)) {
                errors.push('Ethereum address contains invalid characters');
            } else {
                isValid = true;
            }

            return { isValid, addressType: 'EOA', errors };
        }

        function validateLitecoinAddress(address, testnet = false) {
            const errors = [];
            let addressType = 'unknown';
            let isValid = false;

            if (!address) {
                errors.push('Address is required');
                return { isValid, addressType, errors };
            }

            if (testnet) {
                // Testnet patterns
                if (address.startsWith('m') || address.startsWith('n')) {
                    addressType = 'Legacy (P2PKH)';
                    isValid = address.length >= 26 && address.length <= 35;
                } else if (address.startsWith('Q')) {
                    addressType = 'SegWit (P2SH)';
                    isValid = address.length >= 26 && address.length <= 35;
                } else if (address.startsWith('tltc1')) {
                    addressType = 'Native SegWit (Bech32)';
                    isValid = address.length >= 43 && address.length <= 62;
                }
            } else {
                // Mainnet patterns
                if (address.startsWith('L')) {
                    addressType = 'Legacy (P2PKH)';
                    isValid = address.length >= 26 && address.length <= 35;
                } else if (address.startsWith('M')) {
                    addressType = 'SegWit (P2SH)';
                    isValid = address.length >= 26 && address.length <= 35;
                } else if (address.startsWith('ltc1')) {
                    addressType = 'Native SegWit (Bech32)';
                    isValid = address.length >= 43 && address.length <= 62;
                }
            }

            if (!isValid && errors.length === 0) {
                errors.push('Invalid Litecoin address format');
            }

            return { isValid, addressType, errors };
        }

        function showResult(elementId, content, type = 'info') {
            const element = document.getElementById(elementId);
            element.style.display = 'block';
            element.className = `result ${type}`;
            element.textContent = content;
        }

        function validateSingleAddress() {
            const address = document.getElementById('address-input').value.trim();
            const network = document.getElementById('network-select').value;
            const testnet = document.getElementById('testnet-checkbox').checked;

            if (!address) {
                showResult('single-result', 'Please enter an address to validate', 'error');
                return;
            }

            let validation;
            switch (network) {
                case 'bitcoin':
                    validation = validateBitcoinAddress(address, testnet);
                    break;
                case 'ethereum':
                    validation = validateEthereumAddress(address);
                    break;
                case 'litecoin':
                    validation = validateLitecoinAddress(address, testnet);
                    break;
                default:
                    validation = { isValid: false, addressType: 'unknown', errors: ['Unsupported network'] };
            }

            let result = `Address Validation Results:\n`;
            result += `Network: ${network.toUpperCase()}${testnet ? ' (Testnet)' : ''}\n`;
            result += `Address: ${address}\n`;
            result += `Valid: ${validation.isValid ? '‚úÖ YES' : '‚ùå NO'}\n`;
            result += `Type: ${validation.addressType}\n`;

            if (validation.errors && validation.errors.length > 0) {
                result += `\nErrors:\n${validation.errors.map(e => `  ‚Ä¢ ${e}`).join('\n')}`;
            }

            const type = validation.isValid ? 'success' : 'error';
            showResult('single-result', result, type);

            // Update explorer links
            updateExplorerLinks(address, network);
        }

        function testOnBlockchain() {
            const address = document.getElementById('address-input').value.trim();
            const network = document.getElementById('network-select').value;

            if (!address) {
                showResult('single-result', 'Please enter an address to test', 'error');
                return;
            }

            // Test on real blockchain
            testAddressOnBlockchain(address, network);
        }

        async function testAddressOnBlockchain(address, network) {
            const explorerUrls = {
                bitcoin: `https://blockstream.info/api/address/${address}`,
                ethereum: `https://api.etherscan.io/api?module=account&action=balance&address=${address}&tag=latest&apikey=demo`,
                litecoin: `https://litecoinspace.org/api/address/${address}`,
                solana: `https://api.mainnet-beta.solana.com`,
                tron: `https://api.trongrid.io/v1/accounts/${address}`
            };

            try {
                const apiUrl = explorerUrls[network];
                if (!apiUrl) {
                    throw new Error(`No API available for ${network}`);
                }

                showResult('single-result', `Testing ${address} on ${network} blockchain...\nFetching data from API...`, 'warning');

                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                
                let result = `Blockchain Test Results:\n`;
                result += `Network: ${network.toUpperCase()}\n`;
                result += `Address: ${address}\n`;
                result += `API Response: ‚úÖ Success\n`;
                
                // Parse response based on network
                switch (network) {
                    case 'bitcoin':
                        const btcBalance = (data.chain_stats?.funded_txo_sum || 0) / 100000000;
                        const btcTxCount = data.chain_stats?.tx_count || 0;
                        result += `Balance: ${btcBalance} BTC\n`;
                        result += `Transactions: ${btcTxCount}\n`;
                        result += `Status: ${btcTxCount > 0 ? '‚úÖ Active address' : '‚úÖ Fresh address'}\n`;
                        break;
                        
                    case 'ethereum':
                        const ethBalance = parseInt(data.result || '0') / Math.pow(10, 18);
                        result += `Balance: ${ethBalance} ETH\n`;
                        result += `Status: ${ethBalance > 0 ? '‚úÖ Has balance' : '‚úÖ Valid address'}\n`;
                        break;
                        
                    case 'litecoin':
                        const ltcBalance = (data.chain_stats?.funded_txo_sum || 0) / 100000000;
                        const ltcTxCount = data.chain_stats?.tx_count || 0;
                        result += `Balance: ${ltcBalance} LTC\n`;
                        result += `Transactions: ${ltcTxCount}\n`;
                        result += `Status: ${ltcTxCount > 0 ? '‚úÖ Active address' : '‚úÖ Fresh address'}\n`;
                        break;
                        
                    default:
                        result += `Raw response: ${JSON.stringify(data, null, 2)}\n`;
                }

                result += `\n‚úÖ Address exists and is recognized by the ${network} network!`;
                showResult('single-result', result, 'success');

            } catch (error) {
                let result = `Blockchain Test Results:\n`;
                result += `Network: ${network.toUpperCase()}\n`;
                result += `Address: ${address}\n`;
                result += `Error: ${error.message}\n\n`;
                result += `Note: This might be a fresh address (which is good for new wallets)\n`;
                result += `or there might be API limitations. Check the explorer link manually.`;
                
                showResult('single-result', result, 'warning');
            }
        }

        function testKnownValidAddresses() {
            const knownValidAddresses = {
                bitcoin: '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa', // Genesis block address
                ethereum: '0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae', // Ethereum Foundation
                litecoin: 'LTC1qw508d6qejxtdg4y5r3zarvary0c5xw7kg3g4ty', // Example Litecoin address
                solana: '11111111111111111111111111111112', // System program
                tron: 'TLyqzVGLV1srkB7dToTAEqgDSfPtXRJZYH' // Example TRON address
            };

            let result = 'Testing Known Valid Addresses:\n\n';

            for (const [network, address] of Object.entries(knownValidAddresses)) {
                result += `${network.toUpperCase()}:\n`;
                result += `Address: ${address}\n`;
                
                let validation;
                switch (network) {
                    case 'bitcoin':
                        validation = validateBitcoinAddress(address);
                        break;
                    case 'ethereum':
                        validation = validateEthereumAddress(address);
                        break;
                    case 'litecoin':
                        validation = validateLitecoinAddress(address);
                        break;
                    default:
                        validation = { isValid: false, addressType: 'unknown', errors: ['Not implemented'] };
                }

                result += `Valid: ${validation.isValid ? '‚úÖ' : '‚ùå'}\n`;
                result += `Type: ${validation.addressType}\n`;
                if (validation.errors && validation.errors.length > 0) {
                    result += `Errors: ${validation.errors.join(', ')}\n`;
                }
                result += '\n';
            }

            showResult('examples-result', result, 'info');
        }

        function testKnownInvalidAddresses() {
            const knownInvalidAddresses = {
                bitcoin: ['1invalid', 'bc1toolong1234567890123456789012345678901234567890', ''],
                ethereum: ['0xinvalid', '0x123', 'notanaddress'],
                litecoin: ['Linvalid', 'ltc1toolong123456789012345678901234567890123456789012345', '']
            };

            let result = 'Testing Known Invalid Addresses:\n\n';

            for (const [network, addresses] of Object.entries(knownInvalidAddresses)) {
                result += `${network.toUpperCase()} Invalid Examples:\n`;
                
                addresses.forEach((address, index) => {
                    let validation;
                    switch (network) {
                        case 'bitcoin':
                            validation = validateBitcoinAddress(address);
                            break;
                        case 'ethereum':
                            validation = validateEthereumAddress(address);
                            break;
                        case 'litecoin':
                            validation = validateLitecoinAddress(address);
                            break;
                        default:
                            validation = { isValid: true, addressType: 'unknown', errors: [] };
                    }

                    result += `  ${index + 1}. "${address || '(empty)'}" - ${validation.isValid ? '‚ùå Should be invalid!' : '‚úÖ Correctly invalid'}\n`;
                });
                result += '\n';
            }

            showResult('examples-result', result, 'info');
        }

        function updateExplorerLinks(address, network) {
            const explorerUrls = {
                bitcoin: `https://blockstream.info/address/${address}`,
                ethereum: `https://etherscan.io/address/${address}`,
                litecoin: `https://blockchair.com/litecoin/address/${address}`,
                solana: `https://solscan.io/account/${address}`,
                tron: `https://tronscan.org/#/address/${address}`
            };

            const linksContainer = document.getElementById('explorer-links');
            const explorerUrl = explorerUrls[network];
            
            if (explorerUrl) {
                linksContainer.innerHTML = `
                    <div class="validation-card">
                        <h4>${network.toUpperCase()} Explorer</h4>
                        <p>Verify this address on the blockchain:</p>
                        <a href="${explorerUrl}" target="_blank" style="color: #667eea; text-decoration: none;">
                            ${explorerUrl}
                        </a>
                        <p style="font-size: 12px; color: #6c757d;">
                            Click to open in ${network} blockchain explorer
                        </p>
                    </div>
                `;
            }
        }

        async function generateAndTestAddresses() {
            showResult('generation-result', 'Generating addresses for all networks...\nThis requires PayCio wallet to be unlocked.', 'warning');

            try {
                // This would integrate with your actual PayCio wallet
                const testAddresses = {
                    bitcoin: '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa', // Example - replace with generated
                    ethereum: '0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae', // Example - replace with generated
                    litecoin: 'LTC1qw508d6qejxtdg4y5r3zarvary0c5xw7kg3g4ty', // Example - replace with generated
                    solana: '11111111111111111111111111111112' // Example - replace with generated
                };

                let result = 'Generated Address Validation:\n\n';

                for (const [network, address] of Object.entries(testAddresses)) {
                    result += `${network.toUpperCase()}:\n`;
                    result += `Generated: ${address}\n`;
                    
                    let validation;
                    switch (network) {
                        case 'bitcoin':
                            validation = validateBitcoinAddress(address);
                            break;
                        case 'ethereum':
                            validation = validateEthereumAddress(address);
                            break;
                        case 'litecoin':
                            validation = validateLitecoinAddress(address);
                            break;
                        default:
                            validation = { isValid: false, addressType: 'unknown', errors: ['Not implemented'] };
                    }

                    result += `Valid: ${validation.isValid ? '‚úÖ' : '‚ùå'}\n`;
                    result += `Type: ${validation.addressType}\n`;
                    
                    if (validation.errors && validation.errors.length > 0) {
                        result += `Issues: ${validation.errors.join(', ')}\n`;
                    }
                    result += '\n';
                }

                result += '\nüí° To test with real generated addresses:\n';
                result += '1. Create a wallet in PayCio\n';
                result += '2. Switch to each network\n';
                result += '3. Copy the generated address\n';
                result += '4. Test it using the validation above\n';

                showResult('generation-result', result, 'info');

            } catch (error) {
                showResult('generation-result', `Error generating addresses: ${error.message}`, 'error');
            }
        }

        function testSpecificNetwork(network) {
            showResult('generation-result', `Testing ${network.toUpperCase()} address generation...\n\nTo test:\n1. Open PayCio wallet\n2. Switch to ${network}\n3. Copy your address\n4. Paste it in the validator above`, 'warning');
        }

        // Auto-run basic tests on page load
        window.addEventListener('load', () => {
            console.log('üß™ Address validation test page ready');
            console.log('Available functions:');
            console.log('- validateSingleAddress()');
            console.log('- testOnBlockchain()');
            console.log('- testKnownValidAddresses()');
            console.log('- generateAndTestAddresses()');
        });

        // Export functions for console use
        window.validateBitcoinAddress = validateBitcoinAddress;
        window.validateEthereumAddress = validateEthereumAddress;
        window.validateLitecoinAddress = validateLitecoinAddress;
        window.testAddressOnBlockchain = testAddressOnBlockchain;
    </script>
</body>
</html>
